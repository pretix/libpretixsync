-- Dialect-specific queries
-- Cannot be part of the table-specific .sq files, as they would generate conflicting query classes

-- Switch to RETURNING once it is also supported by SQLite
getLastInsertedOrderId:
SELECT currval('orders_id_seq') AS Long;

-- Switch to RETURNING once it is also supported by SQLite
getLastInsertedCheckInId:
SELECT currval('checkin_id_seq') AS Long;

-- Switch to RETURNING once it is also supported by SQLite
getLastInsertedCheckInListId:
SELECT currval('checkinlist_id_seq') AS Long;

-- Switch to RETURNING once it is also supported by SQLite
getLastInsertedOrderPositionId:
SELECT currval('orderposition_id_seq') AS Long;

-- Switch to RETURNING once it is also supported by SQLite
getLastInsertedQuestionId:
SELECT currval('question_id_seq') AS Long;

-- Switch to RETURNING once it is also supported by SQLite
getLastInsertedQuotaId:
SELECT currval('quota_id_seq') AS Long;

truncateCheckIn:
TRUNCATE CheckIn;

truncateOrderPosition:
TRUNCATE OrderPosition;

truncateOrder:
TRUNCATE orders;

truncateResourceSyncStatus:
TRUNCATE ResourceSyncStatus;

truncateReusableMedium:
TRUNCATE ReusableMedium;

truncateAllTables:
TRUNCATE
    BadgeLayout,
    BadgeLayoutItem,
    BlockedTicketSecret,
    CachedPdfImage,
    Cashier,
    CheckIn,
    CheckInList,
    CheckInList_Item,
    Closing,
    Event,
    Item,
    ItemCategory,
    MediumKeySet,
    orders,
    OrderPosition,
    Question,
    Question_Item,
    QueuedCall,
    QueuedCheckIn,
    QueuedOrder,
    Quota,
    Quota_Item,
    Receipt,
    ReceiptLine,
    ReceiptPayment,
    ResourceSyncStatus,
    ReusableMedium,
    RevokedTicketSecret,
    Settings,
    SubEvent,
    TaxRule,
    TicketLayout;

searchOrderPosition:
SELECT OrderPosition.*
FROM OrderPosition
LEFT JOIN orders ON OrderPosition.order_ref = orders.id
LEFT JOIN Item ON OrderPosition.item = Item.id
WHERE (
    UPPER(OrderPosition.secret) LIKE :queryStartsWith
    OR UPPER(OrderPosition.attendee_name) LIKE :queryContains
    OR UPPER(OrderPosition.attendee_email) LIKE :queryContains
    OR UPPER(orders.email) LIKE :queryContains
    OR UPPER(orders.code) LIKE :queryStartsWith
)
AND (
    CASE WHEN (:use_event_filter) THEN (orders.event_slug IN :event_filter) ELSE FALSE END
    OR CASE WHEN (:use_event_item_filter) THEN (orders.event_slug IN :event_item_filter_events AND OrderPosition.item IN :event_item_filter_items) ELSE FALSE END
    OR CASE WHEN (:use_event_subevent_filter) THEN (orders.event_slug IN :event_subevent_filter_events AND OrderPosition.subevent_id IN :event_subevent_filter_subevents) ELSE FALSE END
    OR CASE WHEN (:use_all_filter) THEN (orders.event_slug IN :all_filter_events AND OrderPosition.item IN :all_filter_items AND OrderPosition.subevent_id IN :all_filter_subevents) ELSE FALSE END
)
LIMIT :limit
OFFSET :offset;

countOrderPositionForStatus:
-- TODO: Check if DISTINCT is required here
SELECT COUNT(DISTINCT OrderPosition.id)
FROM OrderPosition
LEFT JOIN orders ON OrderPosition.order_ref = orders.id
WHERE(
    orders.event_slug = :event_slug
    AND CASE WHEN (:include_pending)
        THEN orders.status IN ('p', 'n')
        ELSE (orders.status = 'p' OR (orders.status = 'n' AND orders.valid_if_pending = TRUE))
    END
    AND CASE WHEN (:subevent_id > 0) THEN OrderPosition.subevent_id = :subevent_id ELSE TRUE END
    AND CASE WHEN (:not_all_items) THEN OrderPosition.item IN :list_item_ids ELSE TRUE END
    AND CASE WHEN (:only_checked_in_list_server_id > 0) THEN
        (OrderPosition.id IN (SELECT position FROM CheckIn WHERE listId = :only_checked_in_list_server_id AND type = 'entry'))
    ELSE
        TRUE
    END
    AND OrderPosition.item = :item_id
    AND CASE WHEN (:variation_id > 0) THEN OrderPosition.variation_id = :variation_id ELSE TRUE END
);

lockQueuedOrder:
UPDATE QueuedOrder
SET
    locked = TRUE
WHERE id = ?;
